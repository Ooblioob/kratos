// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var add_asset, add_remove_user, conf, couch_utils, create_team, get_gh_team_id, get_gh_team_type, gh_conf, git_client, git_url, handle_create_team, handle_remove_repo_event, iced, remove_repo, request, user_db, users, _, __iced_k, __iced_k_noop, _get_or_create_repo,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  _ = require('underscore');

  request = require('request');

  couch_utils = require('../couch_utils');

  users = require('../api/users');

  conf = require('../config');

  gh_conf = conf.RESOURCES.GH;

  git_client = request.defaults({
    auth: gh_conf.ADMIN_CREDENTIALS,
    headers: {
      'User-Agent': 'cfpb-kratos'
    },
    json: true
  });

  git_url = 'https://api.github.com';

  user_db = couch_utils.nano_admin.use('_users');

  get_gh_team_type = function(user, role) {
    var is_contractor, _ref;
    is_contractor = (_ref = user.data) != null ? _ref.contractor : void 0;
    if (is_contractor) {
      return 'write';
    } else {
      return 'admin';
    }
  };

  get_gh_team_id = function(gh_teams, gh_team_type, callback) {
    var team_id;
    team_id = gh_teams[gh_team_type];
    return callback(null, team_id);
  };

  add_remove_user = function(event, team, callback) {
    var action, action_name, body, err, gh_team_type, gh_teams, resp, role, team_id, url, user, user_id, username, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    action_name = event.a;
    user_id = event.v;
    role = event.k;
    gh_teams = team.rsrcs.gh.data;
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/opt/kratos/src/workers/gh.iced"
        });
        users._get_user(user_id, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return user = arguments[1];
            };
          })(),
          lineno: 35
        }));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        var _ref;
        if (err) {
          return callback(err);
        }
        if (__indexOf.call(user.roles, 'gh|user') < 0) {
          return callback();
        }
        username = (_ref = user.rsrcs.gh) != null ? _ref.username : void 0;
        if (!username) {
          return callback({
            user: user,
            err: 'no username'
          });
        }
        gh_team_type = get_gh_team_type(user, role);
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/opt/kratos/src/workers/gh.iced"
          });
          get_gh_team_id(gh_teams, gh_team_type, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return team_id = arguments[1];
              };
            })(),
            lineno: 46
          }));
          __iced_deferrals._fulfill();
        })(function() {
          if (err) {
            return callback(err);
          }
          action = action_name === 'u+' ? git_client.put : git_client.del;
          url = git_url + '/teams/' + team_id + '/memberships/' + username;
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/opt/kratos/src/workers/gh.iced"
            });
            action(url, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  resp = arguments[1];
                  return body = arguments[2];
                };
              })(),
              lineno: 51
            }));
            __iced_deferrals._fulfill();
          })(function() {
            if ((typeof resp !== "undefined" && resp !== null ? resp.statusCode : void 0) >= 400) {
              return callback({
                msg: body,
                code: resp.statusCode
              });
            }
            return callback(err);
          });
        });
      };
    })(this));
  };

  _get_or_create_repo = function(repo_name, callback) {
    var body, err, resp, url, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    url = git_url + '/organizations/' + gh_conf.ORG_ID + '/repos';
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/opt/kratos/src/workers/gh.iced"
        });
        git_client.post({
          url: url,
          json: {
            name: repo_name,
            description: "",
            homepage: "https://github.com",
            "private": false,
            has_issues: true,
            has_wiki: true,
            has_downloads: true
          }
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              resp = arguments[1];
              return body = arguments[2];
            };
          })(),
          lineno: 69
        }));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        if (err) {
          return callback(err);
          return __iced_k();
        } else {
          (function(__iced_k) {
            if (resp.statusCode === 422) {
              url = git_url + '/repos/' + gh_conf.ORG_NAME + '/' + repo_name;
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/opt/kratos/src/workers/gh.iced"
                });
                git_client.get(url, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      err = arguments[0];
                      resp = arguments[1];
                      return body = arguments[2];
                    };
                  })(),
                  lineno: 74
                }));
                __iced_deferrals._fulfill();
              })(function() {
                if (err) {
                  return callback(err);
                } else if (resp.statusCode >= 400) {
                  return callback({
                    msg: body,
                    code: resp.statusCode
                  });
                } else {
                  return callback(null, body);
                }
                return __iced_k();
              });
            } else {
              if (resp.statusCode >= 400) {
                return callback({
                  msg: body,
                  code: resp.statusCode
                });
              } else {
                return callback(null, body);
              }
              return __iced_k();
            }
          })(__iced_k);
        }
      };
    })(this));
  };

  add_asset = function(repo_name, team, callback) {
    var bods, err, errors, errs, existing_repo, k, new_repo, new_repo_data, resps, team_id, team_name, url, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    existing_repo = _.findWhere((_ref = team.rsrcs.gh) != null ? _ref.assets : void 0, {
      'name': repo_name
    });
    if (existing_repo) {
      return callback(null);
    }
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/opt/kratos/src/workers/gh.iced"
        });
        _get_or_create_repo(repo_name, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return new_repo_data = arguments[1];
            };
          })(),
          lineno: 92
        }));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        if (err) {
          return callback(err);
          return __iced_k();
        } else {
          new_repo = {
            gh_id: new_repo_data.id,
            name: new_repo_data.name,
            full_name: new_repo_data.full_name
          };
          errs = {};
          resps = {};
          bods = {};
          (function(__iced_k) {
            var _ref1, _ref2;
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/opt/kratos/src/workers/gh.iced"
            });
            _ref2 = ((_ref1 = team.rsrcs.gh) != null ? _ref1.data : void 0) || {};
            for (team_name in _ref2) {
              team_id = _ref2[team_name];
              url = git_url + '/teams/' + team_id + '/repos/' + new_repo.full_name;
              git_client.put(url, __iced_deferrals.defer({
                assign_fn: (function(__slot_1, __slot_2, __slot_3, __slot_4, __slot_5, __slot_6) {
                  return function() {
                    __slot_1[__slot_2] = arguments[0];
                    __slot_3[__slot_4] = arguments[1];
                    return __slot_5[__slot_6] = arguments[2];
                  };
                })(errs, team_id, resps, team_id, bods, team_id),
                lineno: 107
              }));
            }
            __iced_deferrals._fulfill();
          })(function() {
            var _i, _len, _ref1;
            errors = {};
            _ref1 = _.keys(errs);
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              k = _ref1[_i];
              if (errs[k] || resps[k].statusCode >= 400) {
                errors[k] = {
                  err: errs[k],
                  msg: bods[k],
                  code: resps[k].statusCode
                };
              }
            }
            if (_.isEmpty(errors)) {
              return callback(null, new_repo);
            } else {
              return callback(errors);
            }
            return __iced_k();
          });
        }
      };
    })(this));
  };

  remove_repo = function(repo_full_name, team, callback) {
    var bods, errors, errs, k, resps, team_id, team_name, url, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    errs = {};
    resps = {};
    bods = {};
    (function(_this) {
      return (function(__iced_k) {
        var _ref, _ref1;
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/opt/kratos/src/workers/gh.iced"
        });
        _ref1 = ((_ref = team.rsrcs.gh) != null ? _ref.data : void 0) || {};
        for (team_name in _ref1) {
          team_id = _ref1[team_name];
          url = git_url + '/teams/' + team_id + '/repos/' + repo_full_name;
          git_client.del(url, __iced_deferrals.defer({
            assign_fn: (function(__slot_1, __slot_2, __slot_3, __slot_4, __slot_5, __slot_6) {
              return function() {
                __slot_1[__slot_2] = arguments[0];
                __slot_3[__slot_4] = arguments[1];
                return __slot_5[__slot_6] = arguments[2];
              };
            })(errs, team_id, resps, team_id, bods, team_id),
            lineno: 125
          }));
        }
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        var _i, _len, _ref;
        errors = {};
        _ref = _.keys(errs);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          k = _ref[_i];
          if (errs[k] || resps[k].statusCode >= 400) {
            errors[k] = {
              err: errs[k],
              msg: bods[k],
              code: resps[k].statusCode
            };
          }
        }
        if (_.isEmpty(errors)) {
          return callback();
        } else {
          return callback(errors);
        }
      };
    })(this));
  };

  handle_remove_repo_event = function(event, team, callback) {};

  create_team = function(team_name, team) {};

  handle_create_team = function(event, team, callback) {};

  module.exports = {
    handlers: {
      team: {
        'u+': add_remove_user,
        'u-': add_remove_user,
        't+': null,
        't-': null,
        self: {
          'a+': null,
          'a-': handle_remove_repo_event
        },
        other: {
          'a+': null,
          'a-': null
        }
      },
      user: {
        'r+': null,
        'r-': null,
        'u+': null,
        'u-': null
      }
    },
    add_asset: add_asset,
    remove_repo: remove_repo,
    handle_user_event: function(event, doc, callback) {}
  };

}).call(this);
