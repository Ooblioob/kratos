// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var Promise, couch_utils, iced, parse_links, resolve, s, x, _, __iced_k, __iced_k_noop,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  _ = require('underscore');

  s = require('underscore.string');

  couch_utils = require('./couch_utils');

  Promise = require('promise');

  resolve = require('url').resolve;

  parse_links = require('parse-links');

  x = {};

  x.denodeify_all = function(obj) {
    var k, out, v, _results;
    out = {};
    _results = [];
    for (k in obj) {
      v = obj[k];
      if (_.isFunction(v)) {
        _results.push(out[k] = Promise.denodeify(v));
      } else if (_.isObject(v) && !_.isArray(v)) {
        _results.push(out[k] = x.denodeify_all(v));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  x.denodeify_api = function(obj) {
    var k, pName, v, _results;
    _results = [];
    for (k in obj) {
      v = obj[k];
      if (_.isFunction(v) && !s.startsWith(k, 'handle')) {
        pName = 'p' + s.capitalize(k);
        _results.push(obj[pName] = Promise.denodeify(v));
      } else if (_.isObject(v) && !_.isArray(v)) {
        _results.push(x.denodeify_api(v));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  x.mk_objs = function(obj, path_array, val) {
    var key, last_key, _i, _len;
    if (val == null) {
      val = {};
    }

    /*
    make a set of nested object.
    
    obj = {'x': 1}
    mk_objs(obj, ['a', 'b'], ['1'])
     * returns []
     * obj now equals {'x': 1, 'a': {'b': ['1']}}
    
    return the val
     */
    last_key = path_array.pop();
    for (_i = 0, _len = path_array.length; _i < _len; _i++) {
      key = path_array[_i];
      if (obj[key] == null) {
        obj[key] = {};
      }
      obj = obj[key];
    }
    if (!obj[last_key]) {
      obj[last_key] = val;
    }
    return obj[last_key];
  };

  x.process_resp = function(opts, callback) {

    /*
    process a request HTTP response. return a standardized
    error regardless of whether there was a transport error or a server error
    opts is a hash with an optional:
      ignore_codes - array of error codes to ignore, or if 'all' will ignore all http error codes
      body_only - boolean whether to return the body or the full response
     */
    var ignore_codes, is_http_err;
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    ignore_codes = opts.ignore_codes || [];
    is_http_err = function(resp) {
      var _ref;
      if (ignore_codes === 'all' || resp.statusCode < 400 || (_ref = resp.statusCode, __indexOf.call(ignore_codes || [], _ref) >= 0)) {
        return false;
      } else {
        return true;
      }
    };
    return function(err, resp, body) {
      if (err || is_http_err(resp)) {
        err = {
          err: err,
          msg: body,
          code: resp != null ? resp.statusCode : void 0
        };
      }
      if (opts.body_only) {
        return callback(err, body);
      } else {
        return callback(err, resp, body);
      }
    };
  };

  x.PromiseClient = function(client, url_base) {
    var Client;
    Client = {};
    ['get', 'put', 'post', 'del', 'head', 'patch'].forEach(function(method) {
      return Client[method] = Promise.denodeify(function(opts, callback) {
        if (typeof opts === 'string') {
          opts = {
            url: opts
          };
        }
        opts.url = resolve(url_base, opts.url);
        return client[method](opts, x.process_resp(opts, callback));
      });
    });
    Client.get_all = function(opts) {
      var handle_get, results;
      if (typeof opts === 'string') {
        opts = {
          url: opts
        };
      }
      results = [];
      handle_get = function(resp) {
        var link_header, links;
        results = results.concat(resp.body);
        link_header = resp.headers.link;
        if (link_header != null) {
          links = parse_links(link_header);
        }
        opts.url = (links != null ? links.next : void 0) || null;
        if (opts.url) {
          return Client.get(opts).then(handle_get);
        } else {
          return Promise.resolve(results);
        }
      };
      return Client.get(opts).then(handle_get);
    };
    Client.find_one = function(opts, predicate) {

      /*
      keep getting results until we find one that matches predicate
      or we reach last result.
       */
      var handle_get;
      if (typeof opts === 'string') {
        opts = {
          url: opts
        };
      }
      handle_get = function(resp) {
        var link_header, links, result;
        result = _.find(resp.body, predicate);
        link_header = resp.headers.link;
        if (link_header != null) {
          links = parse_links(link_header);
        }
        opts.url = (links != null ? links.next : void 0) || null;
        if (result || !opts.url) {
          return Promise.resolve(result);
        } else {
          return Client.get(opts).then(handle_get);
        }
      };
      return Client.get(opts).then(handle_get);
    };
    return Client;
  };

  x.compact_hash = function(hash) {

    /*
    given a hash return a new hash with only non-falsy values. 
    if the hash will be empty, return undefined
     */
    var out;
    out = _.pick(hash, _.identity);
    if (_.isEmpty(out)) {
      return void 0;
    } else {
      return out;
    }
  };

  x.get_org_dbs = function(callback) {
    var dbs, err, out, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);

    /*
    return all organization databases
     */
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/opt/kratos/src/utils.iced",
          funcname: "get_org_dbs"
        });
        couch_utils.nano_admin.db.list(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return dbs = arguments[1];
            };
          })(),
          lineno: 141
        }));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        if (err) {
          return callback(err);
        }
        out = _.filter(dbs, function(x) {
          return x.indexOf('org_') === 0;
        });
        return callback(null, out);
      };
    })(this));
  };

  module.exports = x;

}).call(this);
